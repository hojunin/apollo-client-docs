<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.8">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Apollo Client 한국어 문서 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Apollo Client 한국어 문서 Atom Feed">
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Q748MW528E"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-Q748MW528E",{})</script><title data-react-helmet="true">아폴로 캐시정책(fetchPolicy) | Apollo Client 한국어 문서</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://www.apollo-kr.site/blog/apollo-fetch-policy"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_tag" content="default"><meta data-react-helmet="true" property="og:title" content="아폴로 캐시정책(fetchPolicy) | Apollo Client 한국어 문서"><meta data-react-helmet="true" name="description" content="이 글은 이 블로그의 글을 의역 및 내용추가한 글입니다."><meta data-react-helmet="true" property="og:description" content="이 글은 이 블로그의 글을 의역 및 내용추가한 글입니다."><meta data-react-helmet="true" property="og:type" content="article"><meta data-react-helmet="true" property="article:published_time" content="2021-10-28T00:00:00.000Z"><meta data-react-helmet="true" property="article:author" content="https://github.com/hojunin"><meta data-react-helmet="true" property="article:tag" content="cache"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://www.apollo-kr.site/blog/apollo-fetch-policy"><link data-react-helmet="true" rel="alternate" href="https://www.apollo-kr.site/blog/apollo-fetch-policy" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://www.apollo-kr.site/blog/apollo-fetch-policy" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.ff7d4088.css">
<link rel="preload" href="/assets/js/runtime~main.748b3031.js" as="script">
<link rel="preload" href="/assets/js/main.1a53649c.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/apollo_logo.png" alt="Apollo" class="themedImage_1VuW themedImage--light_3UqQ"><img src="/img/apollo_logo.png" alt="Apollo" class="themedImage_1VuW themedImage--dark_hz6m"></div><b class="navbar__title">아폴로 클라이언트 번역본</b></a><a class="navbar__item navbar__link" href="/docs/intro">문서 보기</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">블로그</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/hojunin" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>개발자 : HojunIn<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_71bT toggle_3Zt9 toggleDisabled_3cF-"><div class="toggleTrack_32Fl" role="button" tabindex="-1"><div class="toggleTrackCheck_3lV7"><span class="toggleIcon_O4iE">🌜</span></div><div class="toggleTrackX_S2yS"><span class="toggleIcon_O4iE">🌞</span></div><div class="toggleTrackThumb_xI_Z"></div></div><input type="checkbox" class="toggleScreenReader_28Tw" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper blog-wrapper blog-post-page"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_2ahu thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_2hhb margin-bottom--md">Recent posts</div><ul class="sidebarItemList_2xAf"><li class="sidebarItem_2UVv"><a aria-current="page" class="sidebarItemLink_1RT6 sidebarItemLinkActive_12pM" href="/blog/apollo-fetch-policy">아폴로 캐시정책(fetchPolicy)</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/welcome">환영합니다</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="blogPostTitle_GeHD" itemprop="headline">아폴로 캐시정책(fetchPolicy)</h1><div class="blogPostData_291c margin-vert--md"><time datetime="2021-10-28T00:00:00.000Z" itemprop="datePublished">October 28, 2021</time> · <!-- -->9 min read</div><div class="row margin-top--md margin-bottom--sm"><div class="col col--6 authorCol_1R69"><div class="avatar margin-bottom--sm"><a href="https://github.com/hojunin" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img class="image_1yU8" src="https://github.com/hojunin.png" alt="인호준"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/hojunin" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">인호준</span></a></div><small class="avatar__subtitle" itemprop="description">성장중인 개발자</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>이 글은 <a href="https://medium.com/@galen.corey/understanding-apollo-fetch-policies-705b5ad71980" target="_blank" rel="noopener noreferrer">이 블로그</a>의 글을 의역 및 내용추가한 글입니다.</p><p>Apollo Client는 굉장히 똑똑하게 자원을 관리하는데, 그 중 으뜸인 기능이 바로 Apollo Cache입니다. 왜냐하면 속도의 측면에서 다음과 같은 공식이 성립하기 때문에 그렇습니다.</p><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>tip</h5></div><div class="admonition-content"><h3 class="anchor anchorWithStickyNavbar_31ik" id="network--cache">Network &lt; Cache<a aria-hidden="true" class="hash-link" href="#network--cache" title="Direct link to heading">​</a></h3></div></div><p>즉, 직접 서버에 호출하는 동작보다 과거에 받았던 데이터를 잠깐 저장하는 캐시에서 받아오는게 훨씬 빠릅니다.그렇게 좋은거면 항상 cache를 이용하면 되지 않을까요? 하지만 캐시는 실제 데이터와의 괴리가 발생할 가능성이 있어 명확함을 요하는 부분에서는 사용해서는 안되고, 토큰같이 저장해선 안되는 데이터가 캐시에 저장되어있는 경우도 있으므로 개발 단계에서 이 부분을 신경써야 합니다.</p><p>그래서 아폴로에서는, 우리가 그 방식을 선택할 수 있게 <code>페칭 정책(fetching policy)</code>을 만들어 놓았습니다. 쿼리를 날리고 받은 결과값을 캐시에 저장하고 나중에 똑같은 콜을 하면 불필요하게 서버에 다시 요청하지 않고 그냥 cache에 있는 결과값을 그대로 가져다 씁니다. 이를 fetch Policy라고 부르는데, 효율성을 위해 cache를 활용할지 network를 활용할 지 정하는 것입니다.</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/c097d9b4-0ed1-4026-bf8f-6d5970742262/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2021-09-19_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.21.51.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20211028%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20211028T124729Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=bcada08114e3dc997990521a16a17e1949c6db0ec15612cae248aa55bf6738b6&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA%25202021-09-19%2520%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE%25203.21.51.png%22" alt="스크린샷 2021-09-19 오후 3.21.51.png"></p><p>위 사진을 보면 <code>useGetArticlesQuery</code>라는 쿼리를 날려서 데이터를 가져오려고 합니다. 이 때 Apollo Client는 Cache에 저장된 데이터를 긁어올지, 서버로 직접 콜을 날릴지에 대한 정책을 선택하게 되는데 그 선택지가 우측에 보이는 6가지 옵션들입니다.</p><hr><h2 class="anchor anchorWithStickyNavbar_31ik" id="cache-first">Cache-First<a aria-hidden="true" class="hash-link" href="#cache-first" title="Direct link to heading">​</a></h2><p>cache-first는 default 옵션입니다. fetchPolicy를 따로 지정하지 않는다면 이 옵션이 선택된다는 뜻입니다.</p><p>cache를 먼저 체크하기 때문에 응답이 빠르다는 점이 특징이고, 데이터가 바뀔 것 같지 않을 때 선택하기 좋습니다. 데이터가 자주 바뀐다면 cache를 거치고 network도 거쳐야 하기 때문에 크게 효율적이지 않습니다.</p><p>작동방식은 다음과 같습니다.</p><p><img src="https://miro.medium.com/max/1400/1*Akd1I7jc0teE_mz15fnZog.jpeg" alt="https://miro.medium.com/max/1400/1*Akd1I7jc0teE_mz15fnZog.jpeg"></p><ol><li>쿼리를 날려 데이터를 fetch해옵니다. Apollo는 Cache에 이전에 받은적 있나 확인해봅니다. 만약 있다면 2,3번 스킵하고 4번으로 이동합니다.</li><li>Cache에 데이터가 없다면 Network Request를 날린다.</li><li>Network Request를 받아서 cache를 update한다.</li><li>Data를 Client에 넘겨준다.</li></ol><h2 class="anchor anchorWithStickyNavbar_31ik" id="cache-and-network">Cache-and-Network<a aria-hidden="true" class="hash-link" href="#cache-and-network" title="Direct link to heading">​</a></h2><p>자주 업데이트되는 데이터를 fetch해올 때 특히 좋습니다. cache-first가 빠른 응답이 특징이라면, cache-and network는 cache를 서버에 맞추어 최신화된 상태로 유지하는데 비중을 둔 정책이라고 볼 수 있습니다. 데이터가 자주 바뀌어서 쿼리가 자꾸 옛날 데이터를 가져온다면, 이 정책을 시도해보면 됩니다.</p><p>작동방식은 다음과 같습니다.</p><p><img src="https://miro.medium.com/max/1400/1*nNwmukDGTnMJ_xDpGndFJw.jpeg" alt="https://miro.medium.com/max/1400/1*nNwmukDGTnMJ_xDpGndFJw.jpeg"></p><ol><li>쿼리를 날려 데이터를 fetch를 시도한다. Apollo는 Cache를 뒤져서 이전에 받은적 있나 확인한다.</li><li>만약 데이터가 cache안에 있으면 cache된 데이터를 리턴한다.</li><li>2번에서 데이터가 있었건 없었건, 서버에다가 요청보내서 Cache에 있는 데이터랑 서버랑 맞는지 확인한다.</li><li>그대로 cache를 update한다.</li><li>update된 데이터를 client에 보내준다.</li></ol><h2 class="anchor anchorWithStickyNavbar_31ik" id="network-only">Network-Only<a aria-hidden="true" class="hash-link" href="#network-only" title="Direct link to heading">​</a></h2><p>만약 실수하면 안되는 타입의 데이터(돈 관련된?) cache에 update되지 않은 데이터가 들어있어서 혹시라도 옛날 데이터로 나온다면 큰 문제가 될 겁니다. 이럴 땐 그냥 속편하게 <strong>효율성 가져다 버리고</strong> network-only policy를 쓰면 됩니다.</p><p>다만 cache를 거치긴 하는데, 이유는 다른 쿼리에서 해당 데이터를 cache-frst나 cache and network로 가져다 쓸 수도 있고 나중에 쓸 수도 있으니까 일단 update 하는겁니다.</p><p>작동 방식은 다음과 같습니다.</p><p><img src="https://miro.medium.com/max/1400/1*I2k6x1p4bWqBhfrBqU5O1w.jpeg" alt="https://miro.medium.com/max/1400/1*I2k6x1p4bWqBhfrBqU5O1w.jpeg"></p><ol><li>Apollo가 cache는 체크하지 않고 직통으로 network request를 날린다.</li><li>서버는 받아서 response를 날려준다. 이걸 받아서 cache를 업데이트 한다.</li><li>update된 cache를 보내준다.</li></ol><h2 class="anchor anchorWithStickyNavbar_31ik" id="no-cache">no-cache<a aria-hidden="true" class="hash-link" href="#no-cache" title="Direct link to heading">​</a></h2><p>이건 network-only와 비슷한 정책인데 차이점이라면 cache를 업데이트 하지 않는다는 점입니다.</p><p>만약 캐쉬나 쿠키같은 곳에 절대 저장되지 않아야 하는 데이터, 꼭 서버에 암호화해서 보관해야 하는 데이터 등은 아예 cache를 이용하지 않아야 합니다. 그럴 때 쓰는 정책이라고 보면 됩니다.</p><p>작동방식은 다음과 같습니다.</p><p><img src="https://miro.medium.com/max/1400/1*LAP8kvXA--rMysxvLDLjuw.jpeg" alt="https://miro.medium.com/max/1400/1*LAP8kvXA--rMysxvLDLjuw.jpeg"></p><ol><li>Apollo가 cache를 거치지 않고 직통으로 network request를 서버에 보낸다.</li><li>서버도 cache를 거치지 않고 직통으로 client에 데이터를 쏴준다.</li></ol><h2 class="anchor anchorWithStickyNavbar_31ik" id="cache-only">cache-only<a aria-hidden="true" class="hash-link" href="#cache-only" title="Direct link to heading">​</a></h2><p>no-cache 정책과 반대로, 이 정책은 network request를 만들어내는걸 금지합니다. 만약 이 정책을 쓰고 cache를 들여댜 봤는데 원하는 데이터가 없다면 바로 error를 뱉습니다. 만약 offline에서 사용할 때 필요한 쿼리가 있다면, 일관된 데이터를 보여줘야 하는 쿼리가 있다면 이 정책을 쓰면 좋습니다.</p><p>작동방식은 다음과 같습니다.</p><p><img src="https://miro.medium.com/max/1400/1*CeTQH5SP2i_XfFFroT6N7Q.jpeg" alt="https://miro.medium.com/max/1400/1*CeTQH5SP2i_XfFFroT6N7Q.jpeg"></p><ol><li>Apollo가 cache를 뒤져서 데이터를 찾는다.</li><li>데이터가 있으면 client에 리턴해주고 없으면 에러를 뱉는다.</li></ol><hr><h3 class="anchor anchorWithStickyNavbar_31ik" id="standby">Standby<a aria-hidden="true" class="hash-link" href="#standby" title="Direct link to heading">​</a></h3><p>cache-first와 동일한 논리로 생각하면 편합니다. 다른점은 특정 필드값이 변할 때 자동으로 캐시를 업데이트해주지 않습니다. refetch나 updateQueries함수를 활용해서 직접 업데이트 해줘야 합니다. 해당 글에서도 다루지 않고 자주 쓰이지도 않으니 알고만 계시면 될 것 같습니다.</p><hr><p>이 fetch-policy 옵션은 거의 default값인 cache-first로 두기 쉬운데, 은근히 이 fetch policy를 아무거나 했다가 무한 쿼리 콜을 한다던가 데이터가 있어야 하는데 비어있다던가 하는 일이 많습니다. 처음 겪어보면 이게 무슨일인가 싶지만, Apollo를 좀 다루다 보면 아, 이거 cache문제가 아닐까 의심하게 됩니다.</p><p>그럴 때 잘 대처하려면 애초에 fetch-policy를 명확하게 알고 사용하는게 좋습니다.</p></div><footer class="row docusaurus-mt-lg blogPostDetailsFull_3kfx"><div class="col"><b>Tags:</b><ul class="tags_2ga9 padding--none margin-left--sm"><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/blog/tags/cache">cache</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/hojunin/apollo-client-docs/blog/2021-10-28-apollo-fetch-policy.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/welcome"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">환영합니다<!-- --> »</div></a></div></nav></main><div class="col col--2"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#cache-first" class="table-of-contents__link toc-highlight">Cache-First</a></li><li><a href="#cache-and-network" class="table-of-contents__link toc-highlight">Cache-and-Network</a></li><li><a href="#network-only" class="table-of-contents__link toc-highlight">Network-Only</a></li><li><a href="#no-cache" class="table-of-contents__link toc-highlight">no-cache</a></li><li><a href="#cache-only" class="table-of-contents__link toc-highlight">cache-only</a><ul><li><a href="#standby" class="table-of-contents__link toc-highlight">Standby</a></li></ul></li></ul></div></div></div></div></div><footer class="footer"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">HOJUN IN</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/hojunin/apollo-client-docs/issues" target="_blank" rel="noopener noreferrer" class="footer__link-item">문의하기</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 HojunIn</div></div></div></footer></div>
<script src="/assets/js/runtime~main.748b3031.js"></script>
<script src="/assets/js/main.1a53649c.js"></script>
</body>
</html>